# Amber 0.3 ISA Overview

Amber v0.3 keeps the compact 12/24-bit instruction classes from v0.2 but rehomes them inside the 48-bit fetch bundle and capability-aware execution model defined in SPEC.md.

## Fetch and Bundles

- The front-end fetches 48-bit bundles aligned on 16-byte boundaries.
- Each bundle slot may hold:
  - four 12-bit instructions,
  - two 24-bit instructions, or
  - one 24-bit plus two 12-bit instructions.
- Branch targets land on 12-bit slot boundaries. The decode stage enumerates slots sequentially; no instruction crosses bundle boundaries.

## Register Files

- **GPRs:** 16 architectural 64-bit registers (`x0..x15`). `x0` reads as zero and discards writes.
- The 12-bit encoding addresses the short subset `x0..x7` for compactness; the 24-bit encoding accesses any GPR.
- **Capabilities:** 18 architectural 128-bit entries split across GC0..GC8 and SC0..SC8 as described in `0.3_capabilities.md`.

## 12-bit Instruction Class

Format: `[11:8]=opcode4, [7:5]=rd3, [4:2]=rs3, [1:0]=mode2` (mode selects immediates or shifts for certain opcodes).

Implemented operations (all single-cycle integer ALU):

- `nop`
- `arithm_add rd, rs`
- `arithm_subtract rd, rs`
- `logic_and rd, rs`
- `logic_or rd, rs`
- `logic_xor rd, rs`
- `logic_shift_left rd, shamt`
- `logic_shift_right rd, shamt`
- `copy rd, rs`
- `branch_short cond, +imm` (signed +/- 192 B window, predicated on `Z`/`NZ` or compare vs zero)
- `csr_read_low rd, csr4`
- `csr_write_low csr4, rs`

Short-form CSR ops cover indices 0..15, matching frequently accessed status registers.

## 24-bit Instruction Class

Format: `[23:18]=major6, [17:14]=rd4, [13:10]=rs1_4, [9:6]=rs2_4_or_cap, [5:0]=opx6_or_imm`.

Major groups adopted in v0.3:

- **ALU / compare:** three-operand add/sub/logic, shifts, rotates, set-less-than (signed/unsigned), min/max, population count, leading/trailing zero count.
- **Immediate / PC-relative:** wide immediates (`copy_upper`, `add_immediate`), long branches and jumps with 18-bit signed offsets in slot units.
- **Load / store (integer):** byte, half, word, double, quad (128-bit) with base capability + either immediate or GPR offset; quad accesses require 16-byte alignment.
- **Capability moves:** `capability_load`, `capability_store`, `capability_set_bounds`, `capability_set_perms`, `capability_seal`, `capability_unseal`, `capability_test`, `capability_jump`, `capability_return`.
- **CSR:** full index space (0..127) via `csr_read`, `csr_write`, `csr_read_set`, `csr_read_clear`.
- **Atomics:** `atomic_load_reserved`, `atomic_store_conditional`, `atomic_compare_swap`, `atomic_fetch_add`, `atomic_swap` on 64-bit operands. (128-bit LR/SC reserved for v0.4.)
- **System:** `system_call imm16`, `kernel_return`, `memory_fence`, `instruction_fence`, `mmu_fence_vma`, `breakpoint`, `sleep` (hint for low-power idle).

## Capability-Aware Addressing

- Every memory reference names a capability register (`GC0..GC8` or `SCx` in privileged code) plus an immediate or index register.
- The effective cursor is `cap.A + offset`; hardware checks bounds, permissions, tag, and sealing before performing the access.
- Short-form loads/stores inherit `GC0` unless a preceding prefix instruction selects another capability (prefix encoding TBD, tracked for v0.4).

## Branch and Call Discipline

- `capability_jump` and `capability_jump_sub` require execute permission; the latter writes the return capability into `SC1` (`LRc`).
- `capability_return` consumes `SC1`, restores the saved `MODE` from `PSTATEc`, and resumes at the sealed/unsealed target.
- Relative branches use slot-based offsets; absolute branches use capability targets.

## CSR and Async Engines

- Multiply, divide/modulus, floating-point, and Oracle-NUMBER engines are accessed via the CSR map. Software writes operands, asserts `start`, and polls `busy` or waits on the corresponding interrupt vector.
- CSR side effects follow read-modify-write semantics defined in SPEC.md. Busy bits are sticky until software clears them by reading the status register.

## Compatibility Notes vs. v0.2

- Existing v0.2 code that relies on the five-slot bundle translates by emitting two 48-bit bundles per previous 128-bit group; fetch hardware treats legacy ROM images containing padding NOP bundles as valid.
- The short ALU opcode assignments match v0.2, limiting assembler churn. New cond-branch forms reuse the same opcode numbers but operate relative to 12-bit slots instead of 16-byte bundles.
- Capability load/store encodings remain in the 24-bit space but now enforce tag and permission checks.

## Items Deferred to v0.4

- Prefix encodings for selecting alternate capability bases in 12-bit instructions.
- Saturating packed integer forms and full 48-bit lane ISA elaboration.
- 128-bit LR/SC atomics and transactional memory constructs.
