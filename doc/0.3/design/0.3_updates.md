# Amber 0.3 Updates

- Adopted the SPEC.md capability-aware system as the architectural baseline while retaining amber v0.2 fetch/execute simplicity. Capabilities now carry sealing, global, permission, OTYPE, exponent, and canonicalization metadata alongside base/bounds.
- Expanded the programmer-visible register set to 16x64-bit GPRs and formalized the 18x128-bit capability file split into GC0..GC8 (general) and SC0..SC8 (system) slots; short 12-bit encodings keep reuse of r0..r7 for compact forms.
- Replaced the five-slot 128-bit fetch bundle with 48-bit bundles that can host 4x12, 2x24, or mixed 24+12 instruction layouts, aligning the decoder with the SPEC format while preserving the v0.2 12/24-bit instruction classes.
- Defined full load/store families (8/16/32/64/128) plus capability load/store, CSR, and system instructions in the 24-bit space; the 12-bit space keeps the tight ALU/core control subset introduced in v0.2.
- Codified the asynchronous math engines (multiply/divide/mod, IEEE-754 FP, Oracle-NUMBER) as CSR-driven units with busy/done bits and precise fault reporting, superseding the placeholder notes in v0.2.
- Established a 128-entry CSR map covering core status, exceptions, MMU, interrupts, PMU, cache control, math engines, DMA/IOMMU/PCIe, and debug, matching SPEC.md expectations while keeping naming aligned with existing RTL stubs.
- Clarified vectored MSI-only interrupt delivery, precise capability fault causes, and user/kernel PSTATE handling; legacy interrupt controller, wide VA/PA fields, and memory model details remain TBD for later revisions.
