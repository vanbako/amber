# Amber 0.4 Core Pipeline Implementation

This note translates the v0.4 microarchitecture description into concrete RTL work items for the core pipeline (front-end through retirement). It assumes the parameterised layout called out in `0.4_impl_overview.md`.

## Module Map

| Stage | Planned Module | Key Interfaces |
| --- | --- | --- |
| IF0 / IF1 | `rtl/core/frontend/if_fetch.sv` | Fetch queue, branch predictor, I-TLB, capability tag cache. |
| IF2 | `rtl/core/frontend/if_align.sv` | Bundle aligner, prefix detector, meta flag propagation. |
| Decode | `rtl/core/decode/decode_top.sv` | 12-bit/24-bit crack, micro-op packing, prefix window updates. |
| Rename | `rtl/core/rename/rename_top.sv` | Integer + capability physical free lists, ROB allocation handshake. |
| Dispatch | `rtl/core/dispatch/dispatch_top.sv` | Cluster selection, queue credits, dependency tags. |
| Issue | `rtl/core/sched/cluster_*.sv` | ALU/capability/LSQ/async queue instances with wakeup-select. |
| Execute | `rtl/core/exec/exec_top.sv` | Functional units, capability check pipeline, bypass network. |
| Writeback | `rtl/core/commit/writeback.sv` | Physical register update, scoreboard clear. |
| Retire | `rtl/core/commit/rob.sv` | Commit sequencing, exception/rollback handling, capability restore. |

Naming is illustrative; final filenames may change but should remain discoverable under the indicated directories.

## Front-End

- The branch predictor combines a TAGE-style predictor with loop tables and a 16-entry return stack. Implement the predictor as a reusable component (`rtl/core/frontend/predictor/`) so variants fit within different FPGA budgets.
- I-cache lines must carry capability metadata (execute permissions, seal bits). The IF0 stage should request this metadata in parallel with the instruction word; IF2 stalls only when a fetched bundle lacks a validated tag.
- Bundle alignment handles up to two 48-bit bundles per cycle. Encode bundle lanes as a packed structure so decode can treat them uniformly when expanding into micro-ops.
- Prefix handling: maintain a per-thread "prefix window" register file that tracks the current GC base. IF2 tags each bundle with prefix metadata so decode knows whether a 12-bit instruction needs window updates.

## Decode and Micro-Op Formation

- Decode cracks up to four micro-ops per cycle. Implement a small FIFO between decode and rename to absorb bubbles when four-wide decode meets two-wide rename in the first implementation.
- Prefix instructions update both architectural state and the rename bookkeeping. Ensure decode marks which micro-ops consume the updated window so rename can insert the proper dependencies.
- Instruction attributes (branch, load/store, async) propagate as enumerated types rather than raw bitfields; this keeps clustered queues type-safe.

## Rename, Allocation, and Dispatch

- Two rename domains exist: integer (64 physical registers) and capability (24 physical registers). Each domain owns a free list, busy map, and speculative checkpoint stack for mispredict recovery.
- ROB allocation (`rob_alloc_if`) carries: destination architectural register, destination physical ID, source physical IDs, capability metadata handles, and exception prediction bits.
- Dispatch partitions micro-ops across ALU, capability, LSQ, and async clusters. The capability cluster enforces that capability-tagged micro-ops serialize only when their metadata is pending.
- For the initial drop, consider parameterising the maximum rename width. Start at four but permit reducing to two without recompiling modules.

## Issue and Execution

- Each issue queue implements classic wakeup-select with age-based arbitration. The queue depth parameters from the design doc (ALU=24, capability=16, LSQ=24, async=8) are defaults; surface them via `localparam` overrides.
- The capability check pipeline sits alongside the execution units: stage 0 normalises base/bounds, stage 1 validates tags/permissions, and stage 2 communicates success/fault back to the ROB.
- Long-latency units (mul/div) plug in through a generic `exec_slot_if` to avoid bespoke scoreboard logic. Ensure the bypass network understands the longer latency and only forwards valid tags.
- Load/store micro-ops exit the issue queue via the LSQ, covered in `0.4_impl_memory_system.md`.

## Commit, Recovery, and Exceptions

- The ROB tracks architectural sequence numbers, destination physical IDs, capability restore tokens, and loan/trace metadata. Recovery pushes rename free lists back to the checkpoint recorded at dispatch.
- Branch mispredicts flush younger entries by rewinding the ROB head/tail and signalling the front-end to restore the predictor window.
- Capability faults (bounds, tag, permission) produce structured exception packets so firmware can diagnose the cause. Preserve both the faulting capability register and the derived cursor/bounds.
- Store commits should only release capability loans once the LSQ confirms the capability metadata is committed. Double-check this handshake with the memory system team.

## Debug and Performance Counters

- Integrate lightweight per-stage counters (rename stalls, issue queue occupancy, mispredict causes) via a shared CSR bus. Avoid gating the critical path; counters can be sampled at retire.
- Include a shadow trace FIFO that streams select events (branch resolve, capability fault, commit) to the debug fabric described in `0.4_impl_multicore.md`.

## Outstanding Tasks

- Finalise the checkpoint depth for rename: current expectation is 16 outstanding branches. Validate against realistic benchmark traces.
- Specify how the capability prefix window interacts with context switches. We need an architectural register snapshot that firmware can save/restore without walking physical IDs.
- Confirm whether dual-core builds share the branch predictor tables or run independent instances. The answer affects how we parameterise the front-end modules.
