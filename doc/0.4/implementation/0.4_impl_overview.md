# Amber 0.4 Implementation Overview

This document kicks off the implementation notes for the Amber v0.4 core and its surrounding infrastructure. It complements the v0.4 design papers under `doc/0.4/design/` by documenting concrete build artefacts, directory layout, and engineering conventions that will guide the RTL and toolchain work through bring-up.

## Scope and Goals

- Track the delta from the v0.1/v0.3 code base toward the deeper, speculative pipeline described in the v0.4 microarchitecture paper.
- Provide an authoritative map for where RTL, verification collateral, and firmware stubs should live in the repository so that follow-on contributors do not have to reverse-engineer the structure.
- Call out blocking tasks, dependencies, and open design-to-implementation questions for each subsystem. Detailed behaviour lives in the companion documents listed below.

## Document Set

At a minimum the v0.4 implementation notes are split across:

- `0.4_impl_core_pipeline.md` – front-end through commit, including rename, issue, mispredict recovery, and capability enforcement units.
- `0.4_impl_memory_system.md` – load/store queues, cache hierarchy, capability tag storage, and interaction with the victim/tagged slice.
- `0.4_impl_multicore.md` – coherent dual-core fabric, interconnect arbitration, interrupt/reset distribution, and shared debug transport.
- `0.4_impl_verification.md` – simulation fixtures, FPGA bring-up checklist, and instrumentation strategy.

Each sub-document references back to this overview for repository layout, build tooling, and dependency tracking.

## Micro-Op Workset

Decode cracks the ISA into the micro-op families below. Proposed tags align with the `uop_pkg` that will live under `rtl/core/common/`. Use the table to drive bring-up checklists and cluster ownership.

| Family | Micro-op tag (planned) | Issue home | Notes |
| --- | --- | --- | --- |
| Scalar integer | `UOP_INT_ALU`, `UOP_INT_SHIFT`, `UOP_INT_BRANCH` | ALU cluster | Carried over from v0.3; widen crack to four entries per cycle and reuse existing bypass metadata. |
| Saturating integer | `UOP_INT_SAT_ADD`, `UOP_INT_SAT_SUB` | ALU cluster | New sticky flag in `CSR_INT_SAT`; execution must raise the flag while preserving legacy overflow behaviour. |
| Packed lanes | `UOP_PACK_ADD_SAT`, `UOP_PACK_SUB_SAT`, `UOP_PACK_AVG`, `UOP_PACK_MINMAX` | ALU cluster (SIMD slice) | Shares datapath with the saturating unit; add lane-qualified bypass valid bits for writeback. |
| Capability prefix management | `UOP_PREFIX_SELECT`, `UOP_PREFIX_CANCEL` | Front-end prefix window + rename bookkeeping | IF2 annotates bundles; rename updates the prefix window file and injects dependency tokens for consumers. |
| Capability mutation | `UOP_CAP_CLONE_RESTRICT`, `UOP_CAP_LOAN_BEGIN`, `UOP_CAP_LOAN_END` | Capability cluster | Extend the normalize/check pipeline with loan token sideband and ROB bookkeeping for rollback. |
| Capability control flow | `UOP_CAP_JUMP`, `UOP_CAP_RET`, `UOP_CALL_COMPACT` (expands to `UOP_CAP_JUMP` + `UOP_LINK`) | Capability cluster + commit | Capture the 3-bit speculation level, update the return stack, and ensure link writes retire atomically. |
| Memory byte operations | `UOP_LD_U8`, `UOP_ST_U8` | LSQ | Expand the LSQ entry format to carry byte enable masks and byte-granular capability permissions. |
| Prefetch and fences | `UOP_MEM_PREFETCH`, `UOP_CAP_FENCE_PREFIX` | Async cluster + LSQ | Prefetches are fire-and-forget; fences flush the prefix window scoreboard before acknowledging commit. |
| Atomic 128-bit | `UOP_LR128`, `UOP_SC128`, `UOP_CAS128` | LSQ + atomic unit | Reserve paired MSHR slots and ensure victim/tag slice handshakes capture the full 16-byte capability region. |
| CSR alias | `UOP_CSR_ALIAS_RD` | ALU cluster | Single-cycle CSR read path; rename must serialize with outstanding CSR writes to avoid read-after-write hazards. |

- Track micro-op implementation status in the verification checklist so DV can gate on per-family completion.
- When a micro-op touches both capability metadata and integer state, make sure the ROB entry carries both physical IDs for precise rollback.
- Document any additional micro-op tags introduced during implementation inside `rtl/core/common/uop_pkg.sv` and mirror the updates here.

### Micro-Op Tag Encodings

Amber v0.4 standardises the micro-op tag field to eight bits. The high nibble identifies the scheduler cluster while the low nibble selects a function variant. The table below fixes the encodings that decode, rename, and verification must share.

| Micro-op tag | Encoding (`uop_tag_t`) | Cluster | Notes |
| --- | --- | --- | --- |
| `UOP_INT_ALU` | `8'h00` | ALU | Legacy integer ALU path. |
| `UOP_INT_SHIFT` | `8'h01` | ALU | Logical/arithmetic shifts. |
| `UOP_INT_BRANCH` | `8'h02` | ALU | Short-form conditional branches and hints. |
| `UOP_INT_SAT_ADD` | `8'h08` | ALU | Raises `CSR_INT_SAT` on clamp. |
| `UOP_INT_SAT_SUB` | `8'h09` | ALU | Shares the saturating datapath with add. |
| `UOP_PACK_ADD_SAT` | `8'h10` | ALU (SIMD slice) | Packed 4x16-bit saturating add. |
| `UOP_PACK_SUB_SAT` | `8'h11` | ALU (SIMD slice) | Packed 4x16-bit saturating sub. |
| `UOP_PACK_AVG` | `8'h12` | ALU (SIMD slice) | Packed average with rounding. |
| `UOP_PACK_MINMAX` | `8'h13` | ALU (SIMD slice) | Packed min/max select. |
| `UOP_PREFIX_SELECT` | `8'h20` | Front-end / Rename | Updates SC5 and prefix window scoreboard. |
| `UOP_PREFIX_CANCEL` | `8'h21` | Front-end / Rename | Cancels active prefix window. |
| `UOP_CAP_CLONE_RESTRICT` | `8'h28` | Capability | Bounds + permission reduce. |
| `UOP_CAP_LOAN_BEGIN` | `8'h29` | Capability | Allocates loan token and marks metadata. |
| `UOP_CAP_LOAN_END` | `8'h2A` | Capability | Releases loan token; serialises with commit. |
| `UOP_CAP_JUMP` | `8'h2C` | Capability | Capability-based control transfer. |
| `UOP_CAP_RET` | `8'h2D` | Capability | Return path with speculation level restore. |
| `UOP_LINK` | `8'h2E` | Capability / Commit | Link register write used by `call_compact`. |
| `UOP_LD_U8` | `8'h30` | LSQ | Byte load with capability metadata. |
| `UOP_ST_U8` | `8'h31` | LSQ | Byte store with byte-enable mask. |
| `UOP_MEM_PREFETCH` | `8'h34` | Async / LSQ | Fire-and-forget capability prefetch. |
| `UOP_CAP_FENCE_PREFIX` | `8'h35` | Async / Commit | Flushes prefix window scoreboard and ROB marks. |
| `UOP_LR128` | `8'h38` | LSQ / Atomic | 128-bit load-reserve sequence start. |
| `UOP_SC128` | `8'h39` | LSQ / Atomic | 128-bit store-conditional. |
| `UOP_CAS128` | `8'h3A` | LSQ / Atomic | 128-bit compare-and-swap. |
| `UOP_ST128_MASK` | `8'h3B` | LSQ / Atomic | Quad-word store with per-lane mask. |
| `UOP_CSR_ALIAS_RD` | `8'h3C` | ALU | Single-cycle CSR alias read. |

Use the same encodings in `uop_pkg.sv`, commit tracing, and DV stimulus so waves remain searchable across tools.

## ISA Instruction Coverage

The ISA additions described in `doc/0.4/design/0.4_isa.md` map onto the micro-op families above. Use this matrix to coordinate decode, execution, and toolchain updates.

| Instruction group | Width | Micro-op mapping | RTL touchpoints |
| --- | --- | --- | --- |
| Prefix management (`cap_prefix_select`, `cap_prefix_cancel`) | 12-bit | `UOP_PREFIX_SELECT`, `UOP_PREFIX_CANCEL` | `rtl/core/frontend/if_align.sv`, `rtl/core/decode/decode_top.sv`, `rtl/core/rename/rename_top.sv` |
| Saturating integer (`int_add_sat`, `int_sub_sat`) | 12-bit | `UOP_INT_SAT_ADD`, `UOP_INT_SAT_SUB` | `rtl/core/exec/exec_top.sv`, `rtl/core/commit/writeback.sv`, `rtl/core/commit/rob.sv` |
| Packed lanes (`pack_add_sat`, `pack_sub_sat`, `pack_avg_round`, `pack_minmax`) | 24-bit | `UOP_PACK_ADD_SAT`, `UOP_PACK_SUB_SAT`, `UOP_PACK_AVG`, `UOP_PACK_MINMAX` | `rtl/core/exec/exec_top.sv`, `rtl/core/sched/cluster_alu.sv` |
| Byte memory (`mem_load_u8`, `mem_store_u8`) | 12-bit | `UOP_LD_U8`, `UOP_ST_U8` | `rtl/core/dispatch/dispatch_top.sv`, `rtl/mem/lsu/lsq.sv`, `rtl/mem/dcache/dcache_top.sv` |
| Prefetch and fences (`mem_prefetch capability`, `capability_fence prefix`) | 24-bit | `UOP_MEM_PREFETCH`, `UOP_CAP_FENCE_PREFIX` | `rtl/mem/lsu/lsq.sv`, `rtl/core/commit/rob.sv`, `rtl/core/frontend/predictor/` |
| Capability loans (`capability_clone_restrict`, `capability_loan_begin`, `capability_loan_end`) | 24-bit | `UOP_CAP_CLONE_RESTRICT`, `UOP_CAP_LOAN_BEGIN`, `UOP_CAP_LOAN_END` | `rtl/core/exec/exec_top.sv`, `rtl/core/sched/cluster_capability.sv`, `rtl/mem/tag_store/cap_tag_cache.sv` |
| Control flow (`branch_short_hint`, `call_compact`, `capability_jump/return` with speculation level) | 24-bit | `UOP_INT_BRANCH`, `UOP_CAP_JUMP`, `UOP_CAP_RET`, `UOP_LINK` | `rtl/core/frontend/predictor/`, `rtl/core/exec/exec_top.sv`, `rtl/core/commit/rob.sv` |
| 128-bit atomics (`atomic_load_reserved_128`, `atomic_store_conditional_128`, `atomic_compare_swap_128`, `mem_store128_mask`) | 24-bit | `UOP_LR128`, `UOP_SC128`, `UOP_CAS128`, `UOP_ST128_MASK` | `rtl/mem/atomic/atomic_unit.sv`, `rtl/mem/lsu/lsq.sv`, `rtl/mem/victim/victim_tag_slice.sv` |
| CSR alias (`csr_read_alias`) | 12-bit | `UOP_CSR_ALIAS_RD` | `rtl/core/exec/exec_top.sv`, `rtl/core/commit/writeback.sv`, `rtl/core/commit/rob.sv` |

- Mirror every instruction in `tests/0.4/` with directed assembly once decode support lands; add coverage bins so DV can prove each encoding issues and retires.
- Update `tools/amber128_asm.py` and the disassembler flow when new mnemonics land; keep the changelog in the verification document in sync with the matrix above.
- When instructions decompose into multiple micro-ops (`call_compact`, prefix fences), annotate the crack logic in `rtl/core/decode/` so waveform debugging can correlate ISA sequences with micro-op flow.

### 12-bit Instruction Encodings

Short-form instructions keep the three-bit major opcode in `instr[11:9]`. New v0.4 encodings consume the previously reserved `0b100`, `0b101`, `0b110`, and `0b111` slots.

| Instruction | Bit pattern (`instr[11:0]`) | Field notes |
| --- | --- | --- |
| `cap_prefix_select gc_idx,len` | `111 rrr ll w 000` | `rrr = GC index (0..7)`, `ll = length (0..3 -> 1..4 ops)`, `w = 1` requests write permission in the prefix window. |
| `cap_prefix_cancel` | `111 000 00 0 111` | All other bits zero; decode treats this singleton value as cancel. |
| `int_add_sat rd, rs` | `101 rrr sss 000` | `rrr = rd`, `sss = rs`. |
| `int_sub_sat rd, rs` | `101 rrr sss 001` | Shares destination/source placement with `int_add_sat`. |
| `mem_load_u8 rd, +imm4` | `100 rrr iiii 00` | `rrrr` is rd, `iiii` is zero-extended 4-bit byte offset added to the active capability cursor. |
| `mem_store_u8 rs, +imm4` | `100 sss iiii 01` | `sss = source register`, `iiii = byte offset`. |
| `csr_read_alias rd, csr4` | `110 rrr cccc 10` | `cccc = CSR index (0..15)`; higher indices require the 24-bit form. |

### 24-bit Instruction Encodings

Long-form instructions reserve the upper nibble (`instr[23:20]`) per functional block. Field names follow the ISA document.

| Instruction | Bit pattern (`instr[23:0]`) | Field notes |
| --- | --- | --- |
| `pack_add_sat rd, rs1, rs2` | `0101 rrrr ssss tttt 0000 0000` | `rrrr = rd`, `ssss = rs1`, `tttt = rs2`. |
| `pack_sub_sat rd, rs1, rs2` | `0101 rrrr ssss tttt 0001 0000` | Function code `0001` in bits `[7:4]`. |
| `pack_avg_round rd, rs1, rs2` | `0101 rrrr ssss tttt 0010 0000` | Function code `0010` in bits `[7:4]`. |
| `pack_minmax rd, rs1, rs2` | `0101 rrrr ssss tttt 0011 0000` | Function code `0011` in bits `[7:4]`. |
| `mem_prefetch capability,+imm12` | `0110 cccc iiii iiii iiii 0000` | `cccc = capability register`, `imm12` is sign-extended. |
| `capability_fence prefix` | `0111 0000 0000 0000 0000 ffff` | `ffff` encodes fence scope: bit0 drain prefix scoreboard, bit1 drain LSQ prefix credits, bit2 flush predictive state, bit3 reserved. |
| `capability_clone_restrict dst, src, perm_mask, bound8` | `1000 dddd ssss pppp bbbb bbbb` | `pppp = permission mask delta`, `bound8 = signed bound adjust in 16-byte quanta`. |
| `capability_loan_begin cap, token, duration12` | `1001 cccc tttt dddd dddd dddd` | `tttt = token slot (0..15)`, `duration12` counts cycles until loan expiry. |
| `capability_loan_end cap, token` | `1001 cccc tttt 1111 1111 0001` | Constant payload differentiates from `loan_begin`. |
| `branch_short_hint cond, +imm16, hint3` | `0011 cccc iiii iiii iiii hhh0` | `cccc = condition code`, `imm16` is PC-relative, `hhh = predictor hint` (`000`=neutral). |
| `call_compact +imm18` | `0100 0000 iiii iiii iiii ii00` | `imm18` multiplies by four; low bits zero to preserve alignment. |
| `capability_jump cap, target` | `0010 cccc iiii iiii iiii ss00` | `ssss` (`instr[3:1]`) is 3-bit speculation level; mirrors existing encoding otherwise. |
| `capability_return cap` | `0010 cccc 0000 0000 0000 ss01` | `ssss` as above; `cap` selects source capability. |
| `atomic_load_reserved_128 rd, capability` | `1100 rrrr cccc 0000 0000 0000` | Reserves paired register `rd+1` implicitly. |
| `atomic_store_conditional_128 rd, capability` | `1100 rrrr cccc 0000 0000 0001` | Writes from `rd:rd+1`; result in `rd`. |
| `atomic_compare_swap_128 rd, rs1, capability` | `1100 rrrr ssss cccc 0000 0010` | `rd` carries compare value, `rs1` desired, both consume paired registers. |
| `mem_store128_mask rs, mask4, capability` | `1100 ssss mmmm cccc 0000 0011` | `mmmm` supplies per-32-bit lane mask. |

- Keep assembler/disassembler tables aligned with these bit patterns so tooling produces the same hex seen in simulation traces.
- DV scoreboard models should key off the major opcode nibble (`instr[23:20]`) and function codes noted above to avoid mismatched decodes.
- Any future expansion must reserve new function codes inside the same major nibble to preserve binary compatibility.

## Source Layout (In Flight)

Amber v0.4 promotes the older `src/0.1` layout into a parameterised tree rooted under `src/0.4`. The target structure is summarised below; directories marked _TBD_ do not yet exist and are placeholders for upcoming commits.

| Area | Path | Notes |
| --- | --- | --- |
| Common packages | `src/0.4/rtl/common/` _(TBD)_ | Shared typedefs, capability metadata records, centrally parameterised constants. |
| Core pipeline | `src/0.4/rtl/core/` _(TBD)_ | Front-end, rename, ROB, clustered schedulers, retirement logic. See `0.4_impl_core_pipeline.md`. |
| Memory hierarchy | `src/0.4/rtl/mem/` _(TBD)_ | L1 caches, victim/tag slice, capability tag arrays, LSQ. See `0.4_impl_memory_system.md`. |
| Fabric & uncore | `src/0.4/rtl/fabric/` _(TBD)_ | Dual-core coherency fabric, interrupt controller, CSR hub. |
| Simulation | `src/0.4/sim/` _(TBD)_ | SystemVerilog test benches, behavioural memory, trace capture. |
| Firmware stubs | `tests/0.4/` _(present)_ | Placeholders for ISA/ABI tests and directed capability programs. |

Where v0.4 reuses legacy modules (for example the UART stub or reset synchroniser) we will continue sourcing them from `src/0.1/rtl/platform` until the modules are refreshed. The goal is to retire `src/0.1` once v0.4 has equivalent coverage.

## Build and Simulation Hooks

- The existing Verilator wrapper `tools/run_verilator.sh` hardcodes v0.1 paths. Extending it to accept a `--release 0.4` flag is the preferred approach so a single entry point can drive both old and new pipelines. See the verification document for the expected module list.
- FPGA builds will keep living under `build/` with the convention `amber40_<target>.bit` or `.sof`. Scripts that currently emit `amber48_*` hex images need v0.4-aware assembly sources once the ISA/toolchain updates land.
- Toolchain work (assembler/disassembler) is already v0.4-capable per `doc/0.4/design/0.4_updates.md`, but the `tools/amber128_asm.py` pipeline must be exercised against the widened instruction encodings before silicon bring-up. Capture any blockers in the verification log.

## Implementation Guidelines

- **Parameterisation:** Every queue depth, cache size, and physical register count introduced in the design spec must surface as a parameter in the RTL. The long-term goal is to cover single-core, dual-core, and research four-cluster derivatives without code duplication.
- **Capability Metadata:** Any module that touches memory or architectural state must thread capability tags, bounds, and seal metadata explicitly. Do not rely on implicit coupling; instead expose structured records from `rtl/common`.
- **Clocking Targets:** Partition major pipelines (front-end, rename, issue, memory) along block-RAM-friendly boundaries to preserve the 180 MHz target on Arora-V. Record timing closure constraints and pragmatic concessions in the relevant subsystem document.

## Open Questions

- How much of the v0.1 simulation harness can be reused without stalling multi-issue bring-up?
- Which debug interface (existing UART trace vs. new CSR-driven capture) should be prioritised for first silicon?
- Do we stabilise on parameter overrides via SystemVerilog `package` constants or Python-based code generation under `tools/`?

Populate answers and decisions in the dedicated subsystem documents; once consensus is achieved, bubble the outcome back into this overview.
