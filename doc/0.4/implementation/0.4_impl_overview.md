# Amber 0.4 Implementation Overview

This document kicks off the implementation notes for the Amber v0.4 core and its surrounding infrastructure. It complements the v0.4 design papers under `doc/0.4/design/` by documenting concrete build artefacts, directory layout, and engineering conventions that will guide the RTL and toolchain work through bring-up.

## Scope and Goals

- Track the delta from the v0.1/v0.3 code base toward the deeper, speculative pipeline described in the v0.4 microarchitecture paper.
- Provide an authoritative map for where RTL, verification collateral, and firmware stubs should live in the repository so that follow-on contributors do not have to reverse-engineer the structure.
- Call out blocking tasks, dependencies, and open design-to-implementation questions for each subsystem. Detailed behaviour lives in the companion documents listed below.

## Document Set

At a minimum the v0.4 implementation notes are split across:

- `0.4_impl_core_pipeline.md` – front-end through commit, including rename, issue, mispredict recovery, and capability enforcement units.
- `0.4_impl_memory_system.md` – load/store queues, cache hierarchy, capability tag storage, and interaction with the victim/tagged slice.
- `0.4_impl_multicore.md` – coherent dual-core fabric, interconnect arbitration, interrupt/reset distribution, and shared debug transport.
- `0.4_impl_verification.md` – simulation fixtures, FPGA bring-up checklist, and instrumentation strategy.

Each sub-document references back to this overview for repository layout, build tooling, and dependency tracking.

## Source Layout (In Flight)

Amber v0.4 promotes the older `src/0.1` layout into a parameterised tree rooted under `src/0.4`. The target structure is summarised below; directories marked _TBD_ do not yet exist and are placeholders for upcoming commits.

| Area | Path | Notes |
| --- | --- | --- |
| Common packages | `src/0.4/rtl/common/` _(TBD)_ | Shared typedefs, capability metadata records, centrally parameterised constants. |
| Core pipeline | `src/0.4/rtl/core/` _(TBD)_ | Front-end, rename, ROB, clustered schedulers, retirement logic. See `0.4_impl_core_pipeline.md`. |
| Memory hierarchy | `src/0.4/rtl/mem/` _(TBD)_ | L1 caches, victim/tag slice, capability tag arrays, LSQ. See `0.4_impl_memory_system.md`. |
| Fabric & uncore | `src/0.4/rtl/fabric/` _(TBD)_ | Dual-core coherency fabric, interrupt controller, CSR hub. |
| Simulation | `src/0.4/sim/` _(TBD)_ | SystemVerilog test benches, behavioural memory, trace capture. |
| Firmware stubs | `tests/0.4/` _(present)_ | Placeholders for ISA/ABI tests and directed capability programs. |

Where v0.4 reuses legacy modules (for example the UART stub or reset synchroniser) we will continue sourcing them from `src/0.1/rtl/platform` until the modules are refreshed. The goal is to retire `src/0.1` once v0.4 has equivalent coverage.

## Build and Simulation Hooks

- The existing Verilator wrapper `tools/run_verilator.sh` hardcodes v0.1 paths. Extending it to accept a `--release 0.4` flag is the preferred approach so a single entry point can drive both old and new pipelines. See the verification document for the expected module list.
- FPGA builds will keep living under `build/` with the convention `amber40_<target>.bit` or `.sof`. Scripts that currently emit `amber48_*` hex images need v0.4-aware assembly sources once the ISA/toolchain updates land.
- Toolchain work (assembler/disassembler) is already v0.4-capable per `doc/0.4/design/0.4_updates.md`, but the `tools/amber128_asm.py` pipeline must be exercised against the widened instruction encodings before silicon bring-up. Capture any blockers in the verification log.

## Implementation Guidelines

- **Parameterisation:** Every queue depth, cache size, and physical register count introduced in the design spec must surface as a parameter in the RTL. The long-term goal is to cover single-core, dual-core, and research four-cluster derivatives without code duplication.
- **Capability Metadata:** Any module that touches memory or architectural state must thread capability tags, bounds, and seal metadata explicitly. Do not rely on implicit coupling; instead expose structured records from `rtl/common`.
- **Clocking Targets:** Partition major pipelines (front-end, rename, issue, memory) along block-RAM-friendly boundaries to preserve the 180 MHz target on Arora-V. Record timing closure constraints and pragmatic concessions in the relevant subsystem document.

## Open Questions

- How much of the v0.1 simulation harness can be reused without stalling multi-issue bring-up?
- Which debug interface (existing UART trace vs. new CSR-driven capture) should be prioritised for first silicon?
- Do we stabilise on parameter overrides via SystemVerilog `package` constants or Python-based code generation under `tools/`?

Populate answers and decisions in the dedicated subsystem documents; once consensus is achieved, bubble the outcome back into this overview.
