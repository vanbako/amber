# Amber 0.4 Capability Model

Amber v0.4 keeps the 128-bit + tag capability representation introduced in v0.3 but strengthens how capabilities flow through the widened instruction stream, speculative microarchitecture, and emerging multi-core fabric. The design goal is to maintain strict authority constraints while allowing short-form code and dual-core configurations to execute without serialization.

## Architectural Capability Set

- **GC0..GC8** continue to serve as general-purpose capabilities for user space. GC0 remains the implicit base for original 12-bit memory forms.
- **SC0..SC8** retain their architectural roles (`PCc`, `LRc`, `SPc`, `SSPc`, `PSTATEc`, interrupt vector roots, and reserved system slots). v0.4 formalizes SC5 as the per-thread capability prefix register described below so short-form code can select a non-GC0 base without a branch to 24-bit instructions.
- Every architectural slot still holds a canonical capability and an out-of-band tag bit. Tags are verified on register loads and must be set for the capability to be usable.

## Encoding and Canonicalization

The v0.4 encoding matches v0.3 and remains compatible with SPEC.md. Canonicalization rules now explicitly cover speculative write-back and multi-core replay scenarios.

```
[127]    S        sealed flag (1 = sealed)
[126]    G        global flag (1 = sharable)
[125:110] PERMS   16-bit authority bitmap (R, W, X, LC, SC, ATOM, SYS, MMIO, CSR, SEAL, UNSEAL, CINV, DMA, SHARE, TRACE, LOAN)
[109:98] OTYPE    12-bit object type used during sealing
[97:92]  E        exponent selecting granularity Q = 2^E
[91:78]  BASE_M   14-bit base mantissa within the Q window
[77:64]  TOP_M    14-bit top mantissa within the Q window (must exceed BASE_M)
[63:0]   A        cursor/offset within the capability
```

- **TRACE:** newly defined permission that allows hardware trace fabric to sample accesses using the capability. Without TRACE, sampling elides payload addresses.
- **LOAN:** indicates the capability may be temporarily delegated to another core or device via the inter-core mailbox; hardware clears the bit automatically when the borrow expires.

Canonicalization mirrors v0.3 but adds:

- Cursor `A` is clamped into `[BASE, TOP)` after every write, even when the write is speculative; squashed writes restore the previous canonical value.
- Borrowed or traced capabilities (`PERMS.LOAN` or `PERMS.TRACE`) may only expand authority when the parent also carried the same bit.
- Seal/unseal paths track a 5-bit spec-depth counter so that nested speculative seals can be unwound in-order without losing canonical metadata.

## Capability Prefix Stream (Short-Form Selection)

- The new 12-bit instruction `cap_prefix_select gc_idx` selects `GCgc_idx` as the base capability for the next 1-4 short-form instructions (window length is encoded in the low two bits). The prefix also records whether the subsequent short-form accesses require write permission.
- `cap_prefix_cancel` immediately terminates the active prefix and reverts the implicit base to GC0. It inserts no bubbles and is free for decoders to eliminate if no prefix is active.
- The prefix state is mirrored in SC5 so interrupts and context switches can save/restore the outstanding window with a single register move. On entry, hardware clears the window length to zero to avoid leaking authority across privilege boundaries.
- Prefix instructions are purely control hints: they do not write architected state beyond SC5 and the implicit short-form selector.

## Derivation and Delegation

- `capability_clone_restrict dst, src` creates a child capability with reduced bounds and permissions in one step. The instruction consumes a 24-bit format slot and guarantees that the resulting capability inherits TRACE/LOAN bits only when present on the parent.
- `capability_loan_begin` and `capability_loan_end` wrap short-term delegation across threads or devices. Loan handles are tracked in the capability's metadata and reflected in the LOAN permission bit; the hardware refuses to retire a `loan_end` unless every borrowed capability is returned.
- The existing `capability_set_bounds` and `capability_set_perms` gain optional saturation: when the requested bounds are tighter than representable by the exponent, hardware rounds inward rather than faulting, and sets a sticky `CAP_BOUNDS_SAT` flag in the CSR map so software can detect the contraction.

## Speculation and Rollback

- Each physical capability register carries a speculative-use flag. Issuing instructions mark the capability before accessing memory or control state. If the instruction later aborts, rename logic restores the pre-speculative contents and tag.
- Speculative loads propagate tag state into the load queue; squashes broadcast `CAP_REPLAY` events that clear derived tags before the result can be observed outside of ROB commit.
- Sealed control transfers allocate dedicated reorder buffer slots so that their capability checks retire in program order even when other instructions bypass them.

## Memory Tagging and Coherence

- Data cache lines continue to store one capability tag per 16-byte sector. The shared L2 victim/tagged cache mirrors the sector tags so either core can satisfy an access without replaying the capability check unless the capability itself changed after the line was filled.
- Directory entries include the capability permission summary (R/W/X/TRACE/LOAN) so cross-core hand-offs can refuse accesses that violate the lender's policy.
- Stores that clear a tag broadcast invalidations to all sharers. Capability stores set the tag, but only after the LOAN/TRACE metadata is merged with any outstanding directory state.

## Faults and Reporting

v0.4 adds or extends the following traps:

- `TRACE_DENY` - execution attempted to trace a capability lacking PERMS.TRACE.
- `LOAN_EXPIRED` - load/store attempted to use a borrowed capability after the loan window elapsed.
- `CAP_BOUNDS_SAT` sticky flag captures the fact that rounding occurred; the associated access still completes unless other faults fire.
- Existing `TAG_CLEAR`, `SEALED`, `PERM`, `BOUNDS`, `OTYPE`, and `MODE` faults behave as in v0.3.

All capability faults log the offending register index, the parent capability (if derivation occurred in-flight), and a snapshot of SC5 when relevant so debuggers can reconstruct prefix state.

## Debug and Profiling Hooks

- New CSRs expose per-cluster capability queue occupancy, prefix window depth, and counts of speculative rollbacks.
- The trace fabric consults PERMS.TRACE and, when present, records the capability ID, effective address, and outcome in the shared debug SRAM.
- Loan traffic increments an inter-core counter that software can sample to detect hot sharing paths and decide whether to materialize shared memory objects.

## Compatibility Notes

- v0.3 binaries continue to run unchanged. Prefix state defaults to GC0 whenever the assembler encounters existing short-form code that does not emit the new `cap_prefix_*` instructions.
- Software that ignores TRACE or LOAN bits observes identical behaviour to v0.3; the bits default to zero on newly created capabilities.
- The CSR layout grows by three registers (prefix window, speculative rollback counter, loan monitor) but preserves all existing indices, keeping debug tooling compatible.
