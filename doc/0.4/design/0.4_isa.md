# Amber 0.4 ISA Overview

Amber v0.4 preserves the 48-bit fetch bundle and dual-width (12/24-bit) instruction classes but augments them to take advantage of the wider front end, capability prefixing, and the new dual-core memory system. All additions remain binary-compatible with v0.3; the assembler selects new encodings only when code opts in.

## Bundles, Prefixes, and Fetch

- Bundles remain aligned to 16-byte boundaries. The front end may fetch two bundles per cycle and perform prefix detection in hardware so prefixes never consume commit bandwidth when they are dead.
- A bundle may contain any mixture of 12- and 24-bit instructions. Prefix instructions always occupy a 12-bit slot and affect subsequent short-form instructions within the same bundle or spill into the next bundle when the window length exceeds the remaining slots.
- Prefix state is architected via SC5. When a trap or interrupt occurs, hardware automatically cancels the prefix window and records the remaining slot count so the handler can restore it if desired.

## Register Files

- **GPRs:** 16 architectural 64-bit registers (`x0..x15`). `x0` continues to hard-wire zero.
- **Capability registers:** The 18-entry GC/SC split is unchanged. New instructions can snapshot and restore the prefix state via SC5 without touching GC0..GC8 contents.
- Short-form instructions address `x0..x7` and the currently selected capability (GC0 by default, GC1..GC8 when selected via prefix). Long-form encodings continue to reach the full register set.

## 12-bit Instruction Class Updates

New short-format operations introduced in v0.4:

- `cap_prefix_select gc_idx,len`: select capability `GCgc_idx` (0..7) for the next `(len + 1)` short-form operations; `len` encodes 0..3 (1..4 instructions).
- `cap_prefix_cancel`: revert to GC0 immediately.
- `int_add_sat rd, rs`: saturating add with implicit overflow clamp, using the new sticky `INT_SAT` status bit.
- `int_sub_sat rd, rs`: saturating subtract.
- `mem_load_u8 rd, +imm4`: zero-extend byte load using the active capability. This replaces the v0.3 pseudo-instruction that expanded to `mem_load_u16` and bit masking.
- `mem_store_u8 rs, +imm4`: byte store under the active capability; the instruction refuses to assemble unless the prefix window or implicit GC0 carries write permission.
- `csr_read_alias rd, csr2`: low-latency access to the new prefix and speculation CSRs.

All existing opcodes retain their original encodings. When the assembler encounters a prefix window length of zero it elides the instruction so existing code sequences remain untouched.

## 24-bit Instruction Class Updates

Major additions:

- **128-bit atomics:** `atomic_load_reserved_128`, `atomic_store_conditional_128`, and `atomic_compare_swap_128` use paired GPR operands and respect capability permissions. They forward through the widened LSQ and benefit from the MEM-stage capability check pipeline.
- **Packed arithmetic:** `pack_add_sat`, `pack_sub_sat`, `pack_avg_round`, and `pack_minmax` operate on four 16-bit lanes inside a 64-bit register. They consume the same major opcode space that was reserved in v0.3.
- **Prefix-friendly loads/stores:** `mem_prefetch capability,+imm12` requests a tagged line fill without architecturally observable loads. The instruction ignores the prefix window and explicitly names a capability register.
- **Capability management:** `capability_clone_restrict`, `capability_loan_begin`, and `capability_loan_end` (see capability model) live in the capability major opcode group. They retain the one-cycle decode latency of other capability instructions.
- **Branch hints:** `branch_short_hint cond,+imm16,hint3` extends the existing conditional branch with a three-bit hint for the hybrid predictor. Hints map to strongly-taken, strongly-not-taken, loop count, or fall-through expectations.

## Control Transfer and Call Discipline

- `capability_jump` and `capability_return` now carry an optional 3-bit speculation level field. Hardware ignores it if the field is zero but records the value in the branch predictor so user code can bias return stack allocation.
- New instruction `call_compact +imm18` expands to a capability jump plus link update but fits in a single 24-bit slot by assuming the prefix window already selected the execute capability. Assemblers only emit it when `SC0` holds the canonical code capability.

## Memory and Atomics

- Long-form memory encodings gain write-masking for quad (128-bit) stores: `mem_store128_mask rd,rs,mask4` writes each 32-bit lane when the corresponding mask bit is set. Capability checks still operate on the full 16-byte region.
- Load/store fences add a `capability_fence prefix` modifier that ensures all in-flight prefix windows drain before the fence completes, preventing aliasing when switching capability bases mid-loop.
- Prefetch and cache-control instructions accept either a capability register or an immediate descriptor that references SC slots. Assembler diagnostics ensure only execute-capable descriptors issue instruction cache prefetch requests.

## CSR Map Additions

v0.4 introduces the following registers while keeping existing indices stable:

- `CSR_PREFIX_STATE` (index 0x18): lower nibble reports active prefix length; upper bits record the selected GC index and permissions.
- `CSR_SPEC_CAP_STATS` (0x19): counts speculative capability uses, rollbacks, and CAP_REPLAY broadcasts.
- `CSR_LOAN_STATUS` (0x1A): tracks outstanding loan tokens per capability register.
- `CSR_INT_SAT` (0x1B): sticky flag indicating any saturating ALU instruction clipped its result.

All CSRs obey standard read/clear semantics and are accessible via short-form `csr_read_alias` when their index is below 16.

## Compatibility Summary

- v0.3 binaries assemble and execute without change. New instructions occupy previously reserved opcode space and are never emitted unless requested.
- Prefix instructions are optional; code that does not emit them continues to use GC0 for short-form memory operations and experiences identical behaviour.
- Toolchain support: the assembler understands `--enable-v0.4` to allow the new mnemonics, while the disassembler annotates prefix windows and loan scopes for easier debugging.

## Deferred Items

- 48-bit explicit vector encodings remain under evaluation. The packed arithmetic subset introduced here is sufficient for DSP kernels without committing to a full vector ISA.
- Transactional memory was deferred again; the widened LSQ and capability rollback infrastructure provide the primitives required but architectural semantics are still under design.
