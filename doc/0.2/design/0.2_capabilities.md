# Amber 0.2 Capability Model (Snapshot)

Amber128 uses 128‑bit capabilities for code and data. This revision focuses on base/bound checks and CAR wiring; permissions/tags are reserved.

## Representation

- `cap[63:0]`   — base (byte address)
- `cap[127:64]` — bound_exclusive (byte address)

An access of size 16 bytes to `addr` is allowed when:
`addr >= base && (addr + 16) <= bound_exclusive`.

## CARs (Capability Architectural Registers)

- `c0=PC` — program counter capability (PCC). Fetch checks the current bundle address against this cap. On each bundle advance the core updates `PC.base` to the next bundle address; `PC.bound` remains unchanged.
- `c1=SP` — stack pointer capability.
- `c2=SSP` — system stack pointer capability.
- `c3=LR` — link register capability.
- `c4=DDC` — default data capability (convention for general data region).
- `c7=PSTATE` — reserved for processor state.

Reset behavior: the core initializes PCC to `{bound=max, base=0}` so early fetches are permitted until software sets bounds.

## Memory Operations

24‑bit forms operate on 128‑bit capability images:

- `cap_ld128 rc, [acap + imm16B]` loads a 128‑bit value from memory into capability register `rc`.
- `cap_st128 [acap + imm16B], rc` stores the 128‑bit content of capability register `rc` to memory.

Both use `acap` for address calculation and bounds checking; the payload is taken from or written to `rc` unchanged.

## Future Work

- Add permissions, validity/tag bits, sealing and object types.
- Enforce cap perms on instruction fetch vs data, and per‑op access modes.
- Multi‑BA capability store/load with tag preservation.

