# Amber48 Implementation 0.1

## Purpose
This note captures the minimum RTL and project scaffolding needed to execute an Amber48 smoke program in Icarus Verilog and on a Gowin Arora-V evaluation board. Anything beyond the items below is intentionally deferred.

## Minimum feature set

### Core
- One-issue, three-stage (IF/ID/EX) pipeline in `rtl/core/amber48_core.v` with synchronous reset and clock enable.
- 16x48 integer register file with `r0` hard-wired to zero plus `SP`, `LR`, `SSP` aliases; no register renaming.
- Scalar ALU covering `add/sub`, `and/or/xor`, `lsl/lsr`; unknown opcodes assert a trap output stub.
- Decoder understands only: `upper_imm`, register-immediate add/sub, BAU-wide load/store, `branch_eq/ne`, `jump`, `jump_sub`, `return`.
- Capabilities are stubbed: `cPCC`/`cDDC` treated as permanently valid, capability writes raise the trap stub.

### Memory + IO
- Instruction memory: 256 BAU entries of synchronous ROM (`rtl/mem/amber48_imem.v`) initialised with `$readmemh`.
- Data memory: 256 BAU entries dual-port RAM (`rtl/mem/amber48_dmem.v`); load/store path applies BAU alignment check and forwards trap stub on failure.
- Simple MMIO window exposing LED heartbeat and UART TX byte for board bring-up; implemented as registers inside the data memory wrapper.
- No caches, MMU, interrupts, or enid fabric in this revision.

### System glue
- Shared clock/reset synchroniser (`rtl/platform/reset_sync.v`) used by both simulation and FPGA tops.
- FPGA top (`fpga/gowin_arorav/amber48_top.v`) instantiates the core, Gowin PLL block, maps LED0, UART TX, reset button.
- Constraint file (`fpga/gowin_arorav/amber48_top.pdc`) maps 27 MHz input clock, reset button, LED0, UART pins; reuse Gowin starter kit names.

## Tool flow targets

### Icarus Verilog
- Test bench `sim/tb/amber48_core_tb.v` drives clock (10 ns), applies reset, loads program via `$readmemh`, watches for `trap==PASS`.
- Command: `iverilog -g2012 -o build/amber48_tb sim/tb/amber48_core_tb.v rtl/core/*.v rtl/mem/*.v rtl/platform/*.v` followed by `vvp build/amber48_tb`.
- Wave capture: optional `$dumpfile("wave/amber48_core.fst")` guarded by `ifdef SIM_TRACE`.

### Gowin Arora-V
- Project script `fpga/gowin_arorav/build.tcl` creates the project, adds RTL, applies `amber48_top.pdc`, runs `synthesize`, `place`, `route`, and generates the bitstream.
- Memory initialisation: `amber48_imem` exposes a `parameter INIT_FILE` used by both simulation and FPGA; Gowin flow points it to the same HEX.
- Board validation: LED heartbeat toggles every retired instruction; UART prints `PASS\n` once the smoke program finishes.

## Smoke test workload
1. Assembly stub `tests/add_loop.s` initialises registers, runs a 16-iteration add loop, stores the result to data word 0, and writes ASCII `PASS\n` to the MMIO UART.
2. Helper script `tools/asm_stub.py` converts the stub into BAU-aligned hex for both imem and expected data.
3. Pass criteria:
   - Simulation: test bench prints `PASS` and exits with status 0.
   - FPGA: LED heartbeat is active, UART prints `PASS`, and register viewer via JTAG shows data word 0 == `0x0000_0000_0000_00A0`.

## Deferred to 0.2+
- Packed 24-bit lanes, capability store/load, CSR writes, interrupts.
- Caches, MMU, enid SerDes, DMA-capable peripherals.
- Toolchain integration beyond the hand-written assembler stub.
