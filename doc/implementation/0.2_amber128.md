# Amber128 (v0.2) — Architecture and Implementation

This document captures the Amber 0.2 (“amber128”) design as implemented in RTL under `src/0.2`. It reflects the move to a byte-addressed, 128‑bit word machine with 12/24‑bit instructions packed into 128‑bit bundles and a capability‑centric addressing model.

## Architectural State

- Word size: 128‑bit. Fetch and data transfers are 128‑bit and 16‑byte aligned.
- Data registers: 16 × 64‑bit (`r0..r15`), with `r0==0`.
- Capability registers: 8 × 128‑bit (`c0..c7`). Conventions:
  - `c0=PC` (program counter capability, “PCC”)
  - `c1=SP` (stack pointer capability)
  - `c2=SSP` (system stack pointer capability)
  - `c3=LR` (link register capability)
  - `c4=DDC` (default data capability)
  - `c7=PSTATE` (reserved for processor state)
- CSRs: 128 × 64‑bit (reserved; not yet implemented in RTL).

## Instruction Bundles (5×24)

- Each fetch bundle is 128 bits: `[127:123]` are 5 flag bits; `[119:0]` are five 24‑bit slots (S0..S4).
  - Flag bit 1 → slot contains two 12‑bit instructions.
  - Flag bit 0 → slot contains one 24‑bit instruction.
  - Slots: S0=`[119:96]`, S1=`[95:72]`, S2=`[71:48]`, S3=`[47:24]`, S4=`[23:0]`.
- Instructions never cross bundle boundaries.

### 12‑bit form (in a “2×12” slot)

- Layout: `[11:8]=opcode4, [7:5]=rd3, [4:2]=rs3, [1:0]=reserved`.
- Register fields address `r0..r7`.
- Implemented opcodes: `nop(0)`, `add(1)`, `sub(2)`, `and(3)`, `or(4)`, `xor(5)`, `lsl(6)`, `lsr(7)`, `mov(8)`.

### 24‑bit form (in a “single‑24” slot)

- Layout: `[23:20]=opcode4, [19:16]=rc (cap data reg), [15:13]=acap (address cap), [12:0]=imm13`.
- `imm13` is in 16‑byte units (scaled left by 4 for byte address).
- Implemented opcodes:
  - `cap_ld128(1)`: `c[rc] <- MEM128[ c[acap].base + (imm13<<4) ]`
  - `cap_st128(2)`: `MEM128[ c[acap].base + (imm13<<4) ] <- c[rc]`

## Capability Semantics (snapshot)

- A capability is currently modeled as: `base = cap[63:0]`, `bound_exclusive = cap[127:64]`.
- Memory bounds check (for a 16‑byte access at `addr`): `addr >= base && (addr + 16) <= bound_exclusive`.
- PC bundle fetch is checked against `c0` (PC). On reset, `PC={bound:max, base:0}` to avoid early traps; on each bundle advance, `PC.base` is updated to the new bundle address (bound preserved).
- Permissions, tags, sealing and otypes are reserved for a later revision.

## Memory Model

- IMEM: 128‑bit ROM‑like array; address must be 16‑byte aligned.
- DMEM: 128‑bit RAM‑like array; address must be 16‑byte aligned.
- Simple MMIO is exposed at the top indices of DMEM for LED and UART TX.

## RTL Overview

- `src/0.2/rtl/common/amber128_pkg.sv`: parameters, enums, decode/execute structs.
- `src/0.2/rtl/core/amber128_core.sv`: in‑order core; fetches bundles, decodes per slot, executes ALU, issues 128‑bit mem ops; updates `PC` CAR per bundle.
- `src/0.2/rtl/core/amber128_decoder.sv`: slot decoder (5 flags decide 24b vs 2×12); outputs either a 12‑bit ALU op or a 24‑bit mem op.
- `src/0.2/rtl/core/amber128_alu.sv`: 64‑bit scalar ALU ops; `mov` uses `op_b` as source.
- `src/0.2/rtl/core/amber128_regfile.sv`: 16×64 regfile, 2R/1W.
- `src/0.2/rtl/core/amber128_capfile.sv`: 8×128 capfile, 1W/3R (PC, addr cap, data cap).
- `src/0.2/rtl/mem/amber128_imem.sv`: 128‑bit IMEM with `$readmemh` init.
- `src/0.2/rtl/mem/amber128_dmem.sv`: 128‑bit DMEM with LED/UART MMIO and alignment traps.
- `src/0.2/fpga/gowin_arorav/amber128_top.sv`: FPGA top; reuses reset + UART TX from 0.1.
- `src/0.2/fpga/gowin_arorav/build.tcl`: Gowin project script; generates a placeholder `build/amber128_smoke.hex`.

## Traps and Retirement

- Data fault: raised on DMEM misalignment/out‑of‑bounds or capability bound failure.
- Fetch fault: raised if current bundle address is outside PC capability bounds (after reset init completes).
- `retired_o` pulses on each non‑mem op commit and on each completed mem op.

## Deferred / Roadmap

- Branch/jump/call/return (use LR and SP/SSP CARs); condition flags and CSR block.
- Capability permissions, tags, sealing, otypes; secure loads/stores of capability images.
- Packed subword ops in 64‑bit regs (8/16/24/32/48/64 lanes).
- Tooling: assembler/emitter for 5‑slot bundles; program loader.

