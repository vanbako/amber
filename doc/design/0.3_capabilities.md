# Amber 0.3 Capability Model

Amber v0.3 carries forward the v0.2 base/bound discipline while adopting the richer capability encoding, tag model, and architectural register split from SPEC.md.

## Register File and Naming

- **GC0..GC8** hold application-visible data/code capabilities. `GC0` remains the implicit base for short-form memory ops.
- **SC0..SC8** hold architectural capabilities: `PCc`, `LRc`, `SPc`, `SSPc`, `PSTATEc`, plus four reserved slots for future system features.
- Each capability register is 128 bits plus an out-of-band tag bit. All architectural registers always carry a valid tag; the tag is verified on loads from memory.

## Encoding (128 bits + tag)

Fields follow SPEC.md and are canonicalized by the hardware after every write:

```
[127]    S        sealed flag (1 = sealed)
[126]    G        global flag (1 = sharable)
[125:110] PERMS   16-bit authority bitmap (R, W, X, LC, SC, ATOM, SYS, MMIO, CSR, SEAL, UNSEAL, CINV, DMA, SHARE, RES[1:0])
[109:98] OTYPE    12-bit object type used during sealing
[97:92]  E        exponent selecting granularity Q = 2^E
[91:78]  BASE_M   14-bit base mantissa within the Q window
[77:64]  TOP_M    14-bit top mantissa within the Q window (must exceed BASE_M)
[63:0]   A        cursor/offset within the capability
```

The associated tag bit must be set for a capability to be considered valid. Any non-capability store clears the tag.

### Bounds Reconstruction

With `Q = 1 << E`, hardware computes:

```
H    = A >> (E + 14)
BASE = ((H << 14) | BASE_M) << E
TOP  = ((H << 14) | TOP_M)  << E
```

Memory accesses require `BASE <= A_req` and `A_req + size <= TOP`. Control transfers enforce `BASE <= target < TOP`.

### Canonicalization Rules

- `TOP_M` must be strictly greater than `BASE_M`; violations fault without modifying the destination.
- Cursor `A` is clamped into `[BASE, TOP)` while preserving the finest representable range.
- Attempts to add permissions not present in the source capability fault with `PERM`.
- Sealed capabilities (`S = 1`) may only be used via `capability_unseal` (with matching `OTYPE`) or via sealed control-transfer instructions.

### Derivation Discipline

- `capability_set_bounds` and `capability_set_perms` can only reduce authority; `BASE`, `TOP`, and the permission mask cannot expand beyond the parent.
- `capability_seal` requires `PERMS.SEAL` and preserves bounds; `capability_unseal` requires `PERMS.UNSEAL` and a matching `OTYPE`.
- Local capabilities (`G = 0`) may only be stored or exported when `PERMS.SHARE` is present and the platform policy allows it.

## Tagging in Memory

- Capability stores write the 128-bit payload and set the accompanying memory tag bit.
- Any byte/word/double/quad store clears the tag, preventing forging by raw writes.
- Tagged memory locations survive cache fills and evictions. Tag persistence across DMA or debug access is implementation-defined (TBD in v0.3).

## Fault Model

Capability violations raise precise traps with the following classes:

- `TAG_CLEAR`  – loaded slot had a cleared tag.
- `SEALED`     – operand was sealed and the operation lacked authority.
- `PERM`       – permission bit missing for the attempted access.
- `BOUNDS`     – effective address or target outside `[BASE, TOP)`.
- `OTYPE`      – seal/unseal object type mismatch.
- `MODE`       – capability required kernel mode (`PERMS.SYS`) but `MODE=User`.

Each trap records the offending capability, address, and cause in CSR state so software can recover or terminate safely.

## Compatibility Notes vs. v0.2

- Existing base/bound-only RTL can be layered under the new encoding by fixing `E = 0` and mirroring bounds directly into `BASE_M`/`TOP_M`; this remains compliant but wastes metadata bandwidth until full support is implemented.
- Software visible register names (`PCc`, `SPc`, etc.) match the old `c0..c4` conventions while introducing GC/SC terminology required by SPEC.md.
- Tag storage and sealing operations are new in v0.3; legacy images lacking tag bits must be migrated via trusted code that initializes tags.
