# Amber 0.2 ISA Overview

This document summarizes the instruction set conventions for amber128 (v0.2).

## Instruction Bundles

- 128???bit bundle: [127:123] flag bits, [119:0] five 24???bit slots (S0..S4).
- Flag bit 1 ??? slot holds two 12???bit instructions (first in [23:12], second in [11:0]).
- Flag bit 0 ??? slot holds one 24???bit instruction.
- No cross???bundle instruction fragments.

## 12???bit Instructions

Format: `[11:8]=opcode4, [7:5]=rd3, [4:2]=rs3, [1:0]=reserved` (r0..r7 only).

Implemented opcodes:
- 0: `nop` (no writeback)
- 1: `add rd, rs`
- 2: `sub rd, rs`
- 3: `and rd, rs`
- 4: `or rd, rs`
- 5: `xor rd, rs`
- 6: `lsl rd, rs[5:0]`
- 7: `lsr rd, rs[5:0]`
- 8: `mov rd, rs` (copies `rs` to `rd`)

## 24???bit Instructions

Format: `[23:20]=opcode4, [19:16]=rc (cap data reg), [15:13]=acap (addr cap), [12:0]=imm13`.

Address calculation: `addr = c[acap].base + (imm13 << 4)` (16???byte units).

Implemented opcodes:
- 1: `cap_ld128 rc, [acap + imm]` ??? loads 128 bits into capability `c[rc]`.
- 2: `cap_st128 [acap + imm], rc` ??? stores 128 bits from capability `c[rc]`.
 - 8: `br +imm` — unconditional branch to `PC + (imm13 << 4)`.
 - 9: `beq rd, rs, +imm` — branch if `r[rd] == r[rs]`; `rs` encodes `r0..r7`.
 - A: `bne rd, rs, +imm` — branch if `r[rd] != r[rs]`; `rs` encodes `r0..r7`.

## Architectural Notes

- `r0` is hardwired to zero.
- Capability bounds are checked on every mem op; fetch is checked against PC capability per bundle.
 - Additional forms (conditional branches, CSR, immediates) are reserved for later revisions.

## Updates

- Opcode 8 in the 24-bit format is defined as an unconditional branch to `PC + (imm13 << 4)`. This form does not write back to any register.

